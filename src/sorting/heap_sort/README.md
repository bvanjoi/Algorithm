# 堆排序

## 堆

堆（一般即为二叉堆），在结构上满足如下要求

- 逻辑上是一棵完全二叉树：以大根堆为例，对于某节点 node, 要求其值满足 `node.val >= node.left.val && node.val >= node.right.val`.
- 内部以数组的形式存储：当数组索引以 1 为起始时，完全二叉树满足 left_children_index = index *2, right_children_index = index* 2 + 1 的规律。

堆一般支持以下操作：

- `new`: 实例化一个堆。通常是新建一个空数组。
- `push`: 向堆内插入一个元素；方法是向数组尾部插入一个元素，然后依次与其父亲节点比较，若满足堆的要求，则停止；否则与父亲节点交换位置。该操作的运行时间为 O(logn), 其中 n 为当前数组长度；
- `sift_down`: 维护堆属性的方法。例如在大根堆中，若当前元素小于孩子节点，则该方法可以将其下沉到所需的位置。该方法的运行时间为 O(logn).
- `pop`: 取出根节点。方法是先将数组内的首个元素与尾部元素交换位置，然后数组长度减一已实现根节点的移出，最后对已经处于根节点的尾部元素执行 `sift_down` 操作，将其下沉到满足堆特性的位置。该方法的运行时间为 O(logn).
- `from`: 接受一个数组，将其构建为堆。该操作借助 `sift_down` 执行时，其运行时间为 O(n). （如果使用 `push` 操作建堆，其运行时间为 O(nlogn).

### 备注

在 Rust 的标准库中，提供了数据结构 BinaryHeap, 因此不再重复实现。

## 堆排序算法

在大根堆中，根元素必定是数组内最大的值，每次将根元素取出，随后维护堆；重复该过程，便可以拿出从大到小排列的数组，最后反转即可。

## 示例

初始时，堆内元素为 `[16,14,10,8,7]`, 其二叉树形式如下：

```txt
     16
   /    \
  14    10
 /  \
8    7
```

1. 执行 `pop` 操作，取出顶部元素（16 与 7 交换位置，取出 16, 再将 7 下沉到合适的位置），此时堆的形式为：

    ```txt
        14
      /    \
      8     10
    /
    7 

    [16]
    ```

2. 执行 `pop`, 此时堆为：

    ```txt
      10
    /    \
    8      7

    [16, 14]
    ```

3. 执行 `pop`, 此时堆为：

    ```txt
      8
    /    
    7   

    [16, 14, 10]
    ```

4. 执行 `pop`, 此时堆为：

    ```txt
      7     

    [16, 14, 10, 8]
    ```

5. 执行 `pop`, 此时堆为空，排序结果为 `[16, 14, 10, 8]`.
6. 最终翻转排序结果，结果为：`[8, 10, 14, 16]`.

## 性能

- 运行时间：O(nlogn)
- 空间复杂度：

## 扩展

- 堆经常被用作优先队列。

## 练习

- [排序数组](https://leetcode-cn.com/problems/sort-an-array/)

## 参考

- [heap sort](https://en.wikipedia.org/wiki/Heapsort)
