# 排序问题 - 计数排序

## 算法限制

计数排序要求：

1. 待排序数组中元素只能是整数。
2. 待排序数组 $A$ 内所有元素均处于某一区间；

## 算法

1. 寻找数组 $A$ 中最大元素 max 和最小元素 min;
2. 构建辅助数组 $C$, 其长度为 max - min + 1, 初始元素均为 0;
3. 遍历数组 $A$, 执行 `C[A[i] - min] += 1` 操作。该操作结束后，$C[i]$ 表示 `i + min` 在 $A$ 中出现的次数；
4. 遍历数组 $C$, 将 $C$ 转化为累加数组。该操作结束后，元素 $C[i]$ 表示 $A$ 中小于等于 `i+min` 的元素数；
5. 新建数组 $B$, 其长度与 $A$ 的长度相同；
6. 反向遍历数组 $A$, 执行 `B[C[A[i] - min] - 1] = A[i]`, `C[A[i] - min]] -= 1`, 这两条命令用于将元素放到合适的位置。

## 示例

假设待排序元素为 `[2,5,3,0,2,3,0,3]`.

1. 最大元素为 5, 最小元素为 0;
2. 辅助数组 `C = [0,0,0,0,0,0]`, 长度为 5 - 0 + 1 = 6;
3. 对 `A` 中计数，得到数组 `C` 为 `[2, 0, 2, 3, 0, 1]`;
4. 累加 `C`, 得到 `[2, 2, 4, 7, 7, 8]`;
5. 反向遍历 `A`: 初始时下标为 7.
6. 当下标为 7 时， `A[7]` 的值为 3, `C[3]` 的值为 7, 表示应该将将其放到 `B[7 - 1]` 处，随后执行 `C[3] -= 1`. 此时，`B` 为 `[0,0,0,0,0,0,3,0]`, `C 为`[2, 2, 4, 6, 7, 8]`.
7. 当下标为 6 时， `A[6]` 的值为 0, `C[0]` 的值为 2, 表示应该将将其放到 `B[2 - 1]` 处，随后执行 `C[0] -= 1`. 此时，`B` 为 `[0,0,0,0,0,0,3,0]`, `C 为`[1, 2, 4, 6, 7, 8]`.
8. 当下标为 5 时， `A[5]` 的值为 3, `C[3]` 的值为 6, 表示应该将将其放到 `B[6 - 1]` 处，随后执行 `C[3] -= 1`. 此时，`B` 为 `[0,0,0,0,0,3,3,0]`, `C 为`[1, 2, 4, 5, 7, 8]`.
9. 当下标为 4 时， `A[4]` 的值为 2, `C[2]` 的值为 4, 表示应该将将其放到 `B[4 - 1]` 处，随后执行 `C[2] -= 1`. 此时，`B` 为 `[0,0,0,2,0,3,3,0]`, `C 为`[1, 2, 3, 5, 7, 8]`.
10. 当下标为 3 时， `A[3]` 的值为 0, `C[0]` 的值为 1, 表示应该将将其放到 `B[1 - 1]` 处，随后执行 `C[0] -= 1`. 此时，`B` 为 `[0,0,0,2,0,3,3,0]`, `C 为`[0, 2, 3, 5, 7, 8]`.
11. 当下标为 2 时， `A[2]` 的值为 3, `C[3]` 的值为 5, 表示应该将将其放到 `B[5 - 1]` 处，随后执行 `C[3] -= 1`. 此时，`B` 为 `[0,0,0,2,3,3,3,0]`, `C 为`[0, 2, 3, 4, 7, 8]`.
12. 当下标为 1 时， `A[1]` 的值为 5, `C[5]` 的值为 8, 表示应该将将其放到 `B[8 - 1]` 处，随后执行 `C[5] -= 1`. 此时，`B` 为 `[0,0,0,2,3,3,3,5]`, `C 为`[0, 2, 3, 4, 7, 7]`.
13. 当下标为 0 时， `A[0]` 的值为 2, `C[2]` 的值为 3, 表示应该将将其放到 `B[3 - 1]` 处，随后执行 `C[2] -= 1`. 此时，`B` 为 `[0,0,2,2,3,3,3,5]`, `C 为`[0, 2, 2, 4, 7, 7]`.

## 实现

[计数排序实现](./mod.rs)

## 复杂度

- 运行时间：O(n);
- 空间复杂度：O(max - min);

## 参考

- [count sort](https://en.wikipedia.org/wiki/Counting_sort)
