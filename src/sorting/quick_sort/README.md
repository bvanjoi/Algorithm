# 排序问题 - 快速排序

## 算法

快速排序算法是由 **分治** 实现的，若输入数组为长度为 $n$ 的数组 $A$, 对于区间 `A[p..r]`:

- 若 `p < r` 成立，则将其划分为两部分 `A[p..q]` 和 `A[q+1..r]`, 其中 `i < q && A[i] <= A[q]` 成立，`j > q && A[j] >= A[q]` 成立。其中 `q` 的取值与选择的元素有关，随后递归地对 `A[p..q]`和 `A[q+1..r]` 进行排序；
- 否则，退出递归。

## 示例

例如：待排序的数组 `A` 为 `[2,8,7,1,3,5,6,4]`.

```txt
index:  0   1  2  3  4  5  6  7
A:      [2, 8, 7, 1, 3, 5, 6，4]
```

1. 第一轮：选择下标 0 处的元素作为比较元素，此时 p 为 0, r 为 6, 排序后的结果为：

```txt
index:  0   1  2  3  4  5  6  7 
A:      [1, 2, 7, 8, 3, 5, 6, 4]
         p  q                 r
      q 左侧的元素均小于等于 2
      q 右侧的元素均大于等于 2  
```

2. 第二轮，排序 [0..1] 区间元素，即 `[1,2]`, 该区间会再细分为 `[1]`, `[2]`, 随后退出递归；
3. 第三轮，排序 [2..7] 区间元素，即 `[7,8,3,5,6,4]`, 排序后的结果为：

```txt
index:  0   1  2  3  4  5  6  7 
A:      [1, 2, 6, 4, 3, 5, 7, 8]
               p           q  r
            q 左侧的元素均小于等于 7
            q 右侧的元素均大于等于 7  
```

4. 第四轮，排序 [7..7] 区间的元素，即 `[8]`, 由于此时 `p >= r`, 直接退出递归；
5. 第五轮，排序 [2..6] 区间的元素，即 `[6,4,3,5,7]`, 排序后结果为：

```txt
index:  0   1  2  3  4  5  6  7 
A:      [1, 2, 5, 4, 3, 6, 7, 8]
               p        q  r  
            q 左侧的元素均小于等于 6
            q 右侧的元素均大于等于 6  
```

6. 第六轮，排序 [6..6] 区间的元素，即 `[7]`, 由于此时 `p >= r`, 直接退出递归；
7. 第七轮，排序 [2..5] 区间的元素，即 `[5,4,3,6]`, 排序后结果为：

```txt
index:  0   1  2  3  4  5  6  7 
A:      [1, 2, 3, 4, 5, 6, 7, 8]
               p     q  r
            q 左侧的元素均小于等于 5
            q 右侧的元素均大于等于 5  
```

> 此时，数组已经有序，但是排序算法仍在执行。

8. 第八轮，排序 [5..5] 区间的元素，即 `[6]`, 由于此时 `p >= r`, 直接退出递归；
9. 第九轮，排序 [2..4] 区间的元素，即 `[3,4,5]`, 排序后划分为两个区间：`[3]`, `[4,5]`, 区间 `[3]` 直接返回，区间 `[4,5]` 随后被划分为 `[4]`, `[5]`, 随后退出递归。

排序算法执行结束。

## 实现

[快速排序](./mod.rs)

## 性能

- 最优运行时间：$O(nlogn)$;
- 最坏运行时间：$O(n^2)$;
- 平均运行时间：$O(nlogn)$;

## 扩展

- 当数组内元素有序时，达到最坏运行时间；
- 当数组内元素全部相等时，达到最坏运行时间；
- 当数组内乱序时，达到最优运行时间。

## 练习

- [排序数组](https://leetcode-cn.com/problems/sort-an-array/)

## 参考

- [Quick sort](https://en.wikipedia.org/wiki/Quicksort)
