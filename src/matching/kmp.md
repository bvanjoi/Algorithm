# 字符串匹配问题 - KMP


## 算法

Knuth-Morris-Pratt 算法，简称 KMP 算法。在字符串匹配的过程中，该算法为规避暴力方法中大量无效匹配的操作，使用 next 数组来存储匹配失败时跳转的位置。

其算法流程分为两部分：

1. 构造 s2 的 next 数组；
2. 依据 next 匹配字符串。

### next 数组的构造

next 数组是 KMP 算法的核心：

- next 数组中，第 0 位的值为 -1; 第 i 位(i > 0)存储的是字符串 s 中前 i + 1 位字符串前缀和后缀的最长大长度, 例如对于字符串 abadefg, next[2] 存储的是子串 aba 的前缀和后缀相等时的最大长度。

> 前缀是指字符串内除最后一个字符外的全部头部组合；
>
> 后缀是指字符串内除了第一个字符串意外的全部尾部组合。

求解 next 数组可以使用回溯法：

1. 对于 next[0], 设定其值为 -1;
2. 设定偏移值 k, 其初始值为 -1;
3. 令 i 从 1 循环到 s.len(), 若 `k > -1 && s[k + 1] != s[i]` 则令 `k = next[k]`, 直到不满足该条件；否则若 `s[k+1] == s[i]` 成立，则 `k+=1`, 最后在把当前 k 值赋值给 `next[i]`, 具体过程可见示例。

### 依据 next 匹配字符串

- 假设当前文本字符串 `s1` 匹配的下标为 `i`, 模式字符串 `s2` 匹配的下标为 `j`.
- 若 `j == -1 || s1[i] == s2[j]` 成立，则 `i += 1`, `j+=1`, 表明继续匹配下一个字符；
- 否则即匹配失败，令 `i` 不变，`j = next[j]`, 这意味匹配失败时， `s2` 相对于 `s1` 向右移动了 `j - next[j]`.
- 当 `i == s1.len()` 或 `j == s2.len()` 时跳出循环。若 `j == s2.len()` 成立则表示 `s2` 为 `s1` 的子串。

## 示例

假设 `s1 = ababababac`, `s2=abababac` 为例：

首先，求解 s2 的 next 数组：

- 初始时，k = -1, next = [-1];
- i 从 1 开始迭代，此时，k 的值为 -1, 因此不需要回溯，同时， s[k + 1] == s[i] 不成立（即 s[0] == s[1] 不成立），因此将 -1 赋值给 next[i], 表明前缀和后缀无公共元素.

```txt
index: 0  1 2 3 4 5 6 7
s2:    a  b a b a b a c
next: -1 -1  
          a b a a b c a c
```

- 随后，i = 2, 此时 k 的值 -1, 不需要回溯，同时， s[k + 1] == s[i]（即 s[0] == s[2] 成立），此时需要令 k += 1, 再将 k（此时值为 0）赋值给 next[i], 表明此时存在前后缀的最长公共元素的长度为 1.

```txt
index: 0  1 2 3 4 5 6 7
s2:    a  b a b a b a c
next: -1 -1 0 
            a b a a b c a c
```

- 重复上述过程，直到 i = 7 时的状态为，k 的值 5 > -1 成立，且 s[k + 1] 对应的字符串为 'a', s[i] 对应的字符串为 'c', 二者不相等，则回溯 k 值，令 `k = next[k]`, 直到不满足上述条件。跳出循环后，判断 s[k + 1] == s[i] 是否成立，若成立，则给 next[i] 赋值为 k + 1, 否则给 next[i] 赋值为 k。

```txt
index: 0  1 2 3 4 5 6 7
s2:    a  b a b a b a c
next: -1 -1 0 1 2 3 4 
            a b a b a b a c
```

- 最终，结果为：

```txt
index: 0  1 2 3 4 5 6 7
s2:    a  b a b a b a c
next: -1 -1 0 1 2 3 4 -1
```

此时，next 数组构建完成。

往下，进行字符串匹配

初始时，i = 0, j = 0, 此时 `s1[i] == s2[j]` 不成立，匹配失败，则令 j = -1, 随后一轮，由于

```txt
index: 0123456789 10 11 12 13 14 15 16 17
s1:    acabaabaab c  a  c  c  a  a  b  c
s2:    abaabcac
```

## 实现

[kmp search](./mod.rs)

## 性能

假设 `s1` 的长度为 `n`, `s2` 的长度为 `m`.

- 运行时间：O(n + m).
- 空间复杂度：O(m).

## 参考
