# 字符串问题 - Manacher 算法

## 问题描述

- 输入：给定一个字符串 `S`,
- 输出：字符串 `S` 的最长回文子串。

> 求解最长回文子串的方法有很多，诸如中心扩展法、动态规划、枚举法，但 Manacher 算法性能最优。

## 算法示例

例如，寻找字符串 `cbcbccde` 的最大回文子串。

1. 在每个字符之间插入 `#`, 在头部插入 `^`, 在尾部插入 `$`, 经过处理后的字符串 `T` 长度必然为奇数。

    > `^`, `$` 确保中心扩展时，两端的字符永远不会相等。

    ```txt
    index: 0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18
    T    : ^  #  c  #  b  #  c  #  b  #   c   #   c   #   d   #   e   #   $
    ```

2. 初始化数组 `P`, `P[index]` 记录了以 `index` 为中心的最长回文子串的长度。

    下面，最重要的是 `P[index]` 的求解过程，充分利用回文串的对称性，可以得到：`R = P[index] + C;`, 其中 `R` 为回文串右侧半径；C 表示回文串的中心。

3. 求解 `P` 的示例，当 `i` 指向 `8` 处时，由于回文串的对称性，此时 `P[i] = P[i_mirror]`, 因此 `P[i]` 的值为 3, 而 `R` 的值为 5 + 3.

    ```txt
    index: 0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18
    T    : ^  #  c  #  b  #  c  #  b  #   c   #   c   #   d   #   e   #   $
    P    : 0  0  1  0  3  0  5  0
                   i_mirror  C     i          R
    ```

4. 特殊情况1：`R` 超过了边界，此时 `P[i] = R - C + (T[R + 1] == T[R + 1 - (R + 1 - i) % 2])`.
5. 特殊情况2：`P[i_mirror]` 遇到了原字符串 `S` 的左边界，此时使用中心扩展法。
6. 特殊情况3：`i == R` 成立，此时 `P[i] = 0`.

## 实现

[Manacher 算法](./mod.rs)

## 性能

- 运行时间：O(n);
- 空间：O(1).

## 参考

- [Longest palindromic substring](https://en.wikipedia.org/wiki/Longest_palindromic_substring)
